diff --git a/CMakeLists.txt b/CMakeLists.txt
index 76bfb62..34263b9 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -134,7 +134,7 @@ if(WIN32)
 	set_source_files_properties(src/getopt.c PROPERTIES LANGUAGE CXX)
 else()
 	target_sources(libninja PRIVATE src/subprocess-posix.cc)
-	if(CMAKE_SYSTEM_NAME STREQUAL "OS400" OR CMAKE_SYSTEM_NAME STREQUAL "AIX")
+  if(CMAKE_SYSTEM_NAME STREQUAL "OS400" OR CMAKE_SYSTEM_NAME STREQUAL "AIX" OR CMAKE_SYSTEM_NAME STREQUAL "OS390")
 		target_sources(libninja PRIVATE src/getopt.c)
 		# Build getopt.c, which can be compiled as either C or C++, as C++
 		# so that build environments which lack a C compiler, but have a C++
diff --git a/configure.py b/configure.py
index 09c5b28..fa29210 100755
--- a/configure.py
+++ b/configure.py
@@ -64,12 +64,14 @@ class Platform(object):
             self._platform = 'os400'
         elif self._platform.startswith('dragonfly'):
             self._platform = 'dragonfly'
+        elif self._platform.startswith('zos'):
+            self._platform = 'zos'
 
     @staticmethod
     def known_platforms():
       return ['linux', 'darwin', 'freebsd', 'openbsd', 'solaris', 'sunos5',
               'mingw', 'msvc', 'gnukfreebsd', 'bitrig', 'netbsd', 'aix',
-              'dragonfly']
+              'dragonfly', 'zos']
 
     def platform(self):
         return self._platform
@@ -102,6 +104,9 @@ class Platform(object):
     def is_os400_pase(self):
         return self._platform == 'os400' or os.uname().sysname.startswith('OS400')
 
+    def is_zos(self):
+        return self._platform == 'zos'
+
     def uses_usr_local(self):
         return self._platform in ('freebsd', 'openbsd', 'bitrig', 'dragonfly', 'netbsd')
 
@@ -269,7 +274,11 @@ if configure_env:
     n.variable('configure_env', config_str + '$ ')
 n.newline()
 
-CXX = configure_env.get('CXX', 'c++')
+if platform.is_zos():
+    CXX = configure_env.get('CXX', 'xlclang++')
+else:
+    CXX = configure_env.get('CXX', 'c++')
+
 objext = '.o'
 if platform.is_msvc():
     CXX = 'cl'
@@ -344,6 +353,21 @@ if platform.is_msvc():
     if not options.debug:
         cflags += ['/Ox', '/DNDEBUG', '/GL']
         ldflags += ['/LTCG', '/OPT:REF', '/OPT:ICF']
+elif platform.is_zos():
+    cflags = ['-Wall', '-Wextra',
+       '-Wno-deprecated',
+       '-Wno-missing-field-initializers',
+       '-Wno-unused-parameter',
+       '-+','-qascii',
+       '-qnortti',
+       '-qnoeh',
+       '-DNINJA_PYTHON="%s"' % options.with_python]
+    if options.debug:
+       cflags += ['-g', '-D_GLIBCXX_DEBUG', '-D_GLIBCXX_DEBUG_PEDANTIC']
+       cflags.remove('-qnortti')  # Needed for above pedanticness.
+    else:
+       cflags += ['-O2', '-DNDEBUG']
+    ldflags = ['-L$builddir']
 else:
     cflags = ['-g', '-Wall', '-Wextra',
               '-Wno-deprecated',
@@ -391,6 +415,8 @@ elif platform.is_aix():
     cflags.remove('-fvisibility=hidden')
 elif platform.is_msvc():
     pass
+elif platform.is_zos():
+    pass
 else:
     if options.profile == 'gmon':
         cflags.append('-pg')
@@ -436,6 +462,12 @@ if platform.is_msvc():
         description='CXX $out',
         deps='msvc'  # /showIncludes is included in $cflags.
     )
+elif platform.is_zos():
+    n.rule('cxx',
+        command='$cxx -qmakedep=gcc -MF $out.d $cflags -c $in -o $out',
+        depfile='$out.d',
+        deps='gcc',
+        description='CXX $out')
 else:
     n.rule('cxx',
         command='$cxx -MMD -MT $out -MF $out.d $cflags -c $in -o $out',
@@ -486,7 +518,10 @@ if platform.supports_ninja_browse():
 n.comment('the depfile parser and ninja lexers are generated using re2c.')
 def has_re2c():
     try:
-        proc = subprocess.Popen(['re2c', '-V'], stdout=subprocess.PIPE)
+        if platform.is_zos():
+            proc = subprocess.Popen(['re2c', '-V'], stdout=subprocess.DEVNULL)
+        else:
+            proc = subprocess.Popen(['re2c', '-V'], stdout=subprocess.PIPE)
         return int(proc.communicate()[0], 10) >= 1503
     except OSError:
         return False
@@ -556,6 +591,8 @@ else:
     objs += cxx('subprocess-posix')
 if platform.is_aix():
     objs += cc('getopt')
+elif platform.is_zos():
+    objs += cc('getopt')
 if platform.is_msvc():
     ninja_lib = n.build(built('ninja.lib'), 'ar', objs)
 else:
diff --git a/src/disk_interface.cc b/src/disk_interface.cc
index 7277c3e..d0c1501 100644
--- a/src/disk_interface.cc
+++ b/src/disk_interface.cc
@@ -214,6 +214,8 @@ TimeStamp RealDiskInterface::Stat(const string& path, string* err) const {
     return 1;
 #if defined(_AIX)
   return (int64_t)st.st_mtime * 1000000000LL + st.st_mtime_n;
+#elif defined(__MVS__)
+  return st.st_mtime;
 #elif defined(__APPLE__)
   return ((int64_t)st.st_mtimespec.tv_sec * 1000000000LL +
           st.st_mtimespec.tv_nsec);
diff --git a/src/getopt.c b/src/getopt.c
index 861f07f..cba24d2 100644
--- a/src/getopt.c
+++ b/src/getopt.c
@@ -385,7 +385,7 @@ getopt_internal (int argc, char **argv, char *shortopts,
     return optopt;
 }
 
-#ifndef _AIX
+#if !defined( _AIX) && !defined(__MVS__)
 int
 getopt (int argc, char **argv, char *optstring)
 {
diff --git a/src/getopt.h b/src/getopt.h
index 965dc29..1f93a00 100644
--- a/src/getopt.h
+++ b/src/getopt.h
@@ -39,7 +39,7 @@ extern "C"
   extern int optopt;
 
   /* function prototypes */
-#ifndef _AIX
+#if !defined( _AIX) && !defined(__MVS__)
   int getopt (int argc, char **argv, char *optstring);
 #endif
   int getopt_long (int argc, char **argv, const char *shortopts,
diff --git a/src/manifest_parser_perftest.cc b/src/manifest_parser_perftest.cc
index 853d8e0..daf7a3d 100644
--- a/src/manifest_parser_perftest.cc
+++ b/src/manifest_parser_perftest.cc
@@ -25,7 +25,7 @@
 #ifdef _WIN32
 #include "getopt.h"
 #include <direct.h>
-#elif defined(_AIX)
+#elif defined(_AIX) || defined(__MVS__)
 #include "getopt.h"
 #include <unistd.h>
 #else
diff --git a/src/ninja.cc b/src/ninja.cc
index 9ae53de..8dcabe2 100644
--- a/src/ninja.cc
+++ b/src/ninja.cc
@@ -25,7 +25,7 @@
 #include "getopt.h"
 #include <direct.h>
 #include <windows.h>
-#elif defined(_AIX)
+#elif defined(_AIX) || defined(__MVS__)
 #include "getopt.h"
 #include <unistd.h>
 #else
diff --git a/src/ninja_test.cc b/src/ninja_test.cc
index 6720dec..8178621 100644
--- a/src/ninja_test.cc
+++ b/src/ninja_test.cc
@@ -18,7 +18,7 @@
 
 #ifdef _WIN32
 #include "getopt.h"
-#elif defined(_AIX)
+#elif defined(_AIX) || defined(__MVS__)
 #include "getopt.h"
 #include <unistd.h>
 #else
diff --git a/src/test.cc b/src/test.cc
index 11b1c9e..a9d3016 100644
--- a/src/test.cc
+++ b/src/test.cc
@@ -28,6 +28,10 @@
 #else
 #include <unistd.h>
 #endif
+#ifdef __MVS__
+#include <sys/stat.h>
+#endif
+
 
 #include "build_log.h"
 #include "graph.h"
@@ -200,6 +204,7 @@ void ScopedTempDir::CreateAndEnter(const string& name) {
   start_dir_ = GetSystemTempDir();
   if (start_dir_.empty())
     Fatal("couldn't get system temp dir");
+#ifndef __MVS__
   if (chdir(start_dir_.c_str()) < 0)
     Fatal("chdir: %s", strerror(errno));
 
@@ -210,6 +215,16 @@ void ScopedTempDir::CreateAndEnter(const string& name) {
   char* tempname = mkdtemp(name_template);
   if (!tempname)
     Fatal("mkdtemp: %s", strerror(errno));
+#else
+  char prefix[6];
+  strncpy(prefix,name.c_str(), name.size()>5?5:name.size());
+  prefix[5]='\0';
+  char *tempname = tempnam(start_dir_.c_str(), prefix);
+  if (!tempname)
+    Fatal("tempnam: %s", strerror(errno));
+  if (mkdir(tempname, 0777))
+    Fatal("mkdir: %s",  strerror(errno));
+#endif
   temp_dir_name_ = tempname;
 
   // chdir into the new temporary directory.
diff --git a/src/util.cc b/src/util.cc
index eefa3f5..ce1b281 100644
--- a/src/util.cc
+++ b/src/util.cc
@@ -363,7 +363,7 @@ int ReadFile(const string& path, string* contents, string* err) {
   ::CloseHandle(f);
   return 0;
 #else
-  FILE* f = fopen(path.c_str(), "rb");
+  FILE* f = fopen(path.c_str(), "r");
   if (!f) {
     err->assign(strerror(errno));
     return -errno;
@@ -704,6 +704,9 @@ int GetProcessorCount() {
     }
   }
   return cpuCount;
+#elif defined(__MVS__)
+  // See "MVS Data Area" Book
+  return ((char * __ptr32 * __ptr32 *)0)[4][165][53];
 #else
   int cgroupCount = -1;
   int schedCount = -1;
@@ -812,6 +815,11 @@ double GetLoadAverage() {
   // Calculation taken from comment in libperfstats.h
   return double(cpu_stats.loadavg[0]) / double(1 << SBITS);
 }
+#elif defined(__MVS__)
+double GetLoadAverage() {
+  // Can't determine on z/OS without admin authority.  Assume light load.
+  return 0.0;
+}
 #elif defined(__UCLIBC__) || (defined(__BIONIC__) && __ANDROID_API__ < 29)
 double GetLoadAverage() {
   struct sysinfo si;
